<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Actions Performance Dashboard</title>
    <style>
        /* Basic CSS for layout and visibility */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        header {
            background-color: #24292e;
            /* GitHub dark header color */
            color: #fff;
            padding: 15px 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #f6f8fa;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 180px;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #586069;
            font-size: 0.9em;
        }

        .control-group select,
        .control-group input[type="date"],
        .control-group button {
            padding: 8px 10px;
            border: 1px solid #d1d5da;
            border-radius: 6px;
            font-size: 1em;
            background-color: #fff;
        }

        .status-filter {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-filter label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            color: #24292e;
            cursor: pointer;
        }

        .status-filter input[type="checkbox"] {
            cursor: pointer;
        }

        .control-group button {
            background-color: #2ea44f;
            /* GitHub green button */
            color: #fff;
            cursor: pointer;
            border: none;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .control-group button:hover {
            background-color: #2c974b;
        }

        .preset-buttons {
            display: flex;
            gap: 5px;
        }

        .summary-panel {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .metric-card {
            background-color: #f6f8fa;
            padding: 20px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            flex-grow: 1;
        }

        .metric-card h3 {
            margin: 0 0 10px 0;
            color: #586069;
            font-size: 1em;
            text-transform: uppercase;
        }

        .metric-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #24292e;
        }

        .chart-container {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .chart-container h2 {
            margin-top: 0;
            color: #24292e;
            font-size: 1.4em;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .chart-container .help-text {
            color: #586069;
            font-size: 0.9em;
            margin-top: -10px;
            margin-bottom: 15px;
            font-style: italic;
        }

        .outcomes-widget {
            max-width: 400px;
            margin: 0 auto;
        }

        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #0366d6;
            color: white;
            border-radius: 50%;
            text-align: center;
            font-size: 12px;
            line-height: 16px;
            cursor: help;
            margin-left: 5px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #24292e;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .chart-placeholder {
            width: 100%;
            height: 300px;
            /* Placeholder height for charts */
            background-color: #f0f0f0;
            border: 1px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-style: italic;
        }

        /* Flakiness table styles */
        .metrics-table tbody tr:hover {
            background-color: #f6f8fa;
        }

        .metrics-table a:hover {
            text-decoration: underline;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: none;
        }

        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            position: relative;
            background-color: #fff;
            margin: 50px auto;
            padding: 30px;
            width: 90%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1001;
        }

        .modal-content h2 {
            margin-top: 0;
            color: #24292e;
            font-size: 1.5em;
            border-bottom: 2px solid #e1e4e8;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .modal-content h3 {
            color: #24292e;
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #586069;
            font-size: 0.9em;
        }

        .form-group input[type="text"],
        .form-group input[type="date"] {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d1d5da;
            border-radius: 6px;
            font-size: 1em;
            box-sizing: border-box;
        }

        .form-group input[type="text"]:focus,
        .form-group input[type="date"]:focus {
            outline: none;
            border-color: #0366d6;
            box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.1);
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .btn-primary {
            background-color: #2ea44f;
            color: #fff;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .btn-primary:hover {
            background-color: #2c974b;
        }

        .btn-primary:disabled {
            background-color: #94d3a2;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: #fff;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .preview-info {
            background-color: #f6f8fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            margin-bottom: 15px;
        }

        .preview-info p {
            margin: 8px 0;
            color: #24292e;
            font-size: 1em;
        }

        .progress-container {
            padding: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #e1e4e8;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ea44f 0%, #34d058 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 0.9em;
        }

        .progress-text {
            text-align: center;
            color: #24292e;
            font-size: 1em;
            margin: 10px 0;
        }

        .progress-count {
            text-align: center;
            color: #586069;
            font-size: 0.9em;
            margin: 5px 0;
        }

        .results-summary {
            background-color: #f6f8fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            margin-bottom: 15px;
        }

        .results-summary p {
            margin: 8px 0;
            color: #24292e;
        }

        .results-summary strong {
            color: #24292e;
        }

        .error-message {
            background-color: #ffeef0;
            border: 1px solid #f97583;
            color: #d73a49;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .error-message strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 20px auto;
                padding: 20px;
            }

            .modal-actions {
                flex-direction: column;
            }

            .btn-primary,
            .btn-secondary {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>GitHub Actions Performance Dashboard</h1>
            <div id="token-status" style="margin-top: 10px; font-size: 0.9em;">
                <span id="token-indicator"
                    style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px;"></span>
                <span id="token-text">Checking token status...</span>
                <button id="settings-btn"
                    style="margin-left: 15px; padding: 5px 12px; background-color: #586069; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em;">⚙️
                    Settings</button>
            </div>
        </header>

        <div class="control-panel">
            <div class="control-group">
                <label for="repo-owner">Repository Owner:</label>
                <input type="text" id="repo-owner" value="project-chip">
            </div>
            <div class="control-group">
                <label for="repo-name">Repository Name:</label>
                <input type="text" id="repo-name" value="connectedhomeip">
            </div>
            <div class="control-group">
                <label for="workflow-id">Workflow ID:</label>
                <input type="text" id="workflow-id" value="tests.yaml">
            </div>
            <div class="control-group">
                <label for="start-date">Start Date:</label>
                <input type="date" id="start-date">
            </div>
            <div class="control-group">
                <label for="end-date">End Date:</label>
                <input type="date" id="end-date">
            </div>
            <div class="control-group">
                <label>Presets:</label>
                <div class="preset-buttons">
                    <button data-days="7">Last 7 Days</button>
                    <button data-days="30">Last 30 Days</button>
                    <button data-days="90">Last 90 Days</button>
                </div>
            </div>
            <div class="control-group">
                <label for="period">Group By:</label>
                <select id="period">
                    <option value="day">Day</option>
                    <option value="week">Week</option>
                </select>
            </div>
            <div class="control-group">
                <label style="font-weight: bold;">Workflow Status:</label>
                <div class="status-filter">
                    <label><input type="checkbox" class="status-checkbox" value="success" checked> Success</label>
                    <label><input type="checkbox" class="status-checkbox" value="failure" checked> Failure</label>
                    <label><input type="checkbox" class="status-checkbox" value="cancelled" checked> Cancelled</label>
                    <label><input type="checkbox" class="status-checkbox" value="skipped" checked> Skipped</label>
                    <label><input type="checkbox" class="status-checkbox" value="action_required" checked> Action
                        Required</label>
                </div>
            </div>
            <div class="control-group">
                <label>&nbsp;</label> <!-- Placeholder for alignment -->
                <button id="apply-filters">Apply Filters</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label> <!-- Placeholder for alignment -->
                <button id="export-csv">Export to CSV</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label> <!-- Placeholder for alignment -->
                <button id="fetch-data-btn">Fetch Workflow Data</button>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="modal" style="display: none;">
            <div class="modal-overlay"></div>
            <div class="modal-content">
                <h2>Settings</h2>

                <h3>GitHub Token Configuration</h3>
                <p style="color: #586069; font-size: 0.9em; margin-bottom: 15px;">
                    Configure your GitHub personal access token to fetch workflow data. The token will be encrypted and
                    stored securely.
                </p>

                <div id="token-config-section">
                    <div class="form-group">
                        <label for="github-token-input">GitHub Token:</label>
                        <input type="password" id="github-token-input"
                            placeholder="ghp_xxxxxxxxxxxx or github_pat_xxxxxxxxxxxx"
                            style="width: 100%; padding: 8px 10px; border: 1px solid #d1d5da; border-radius: 6px; font-size: 1em; box-sizing: border-box;">
                        <small style="color: #586069; font-size: 0.85em; display: block; margin-top: 5px;">
                            Token should start with 'ghp_', 'github_pat_', or 'gho_'
                        </small>
                    </div>

                    <div id="token-status-info"
                        style="background-color: #f6f8fa; padding: 12px; border-radius: 6px; border: 1px solid #e1e4e8; margin-bottom: 15px;">
                        <p style="margin: 5px 0;"><strong>Current Status:</strong> <span
                                id="current-token-status">Loading...</span></p>
                        <p style="margin: 5px 0;"><strong>Source:</strong> <span id="current-token-source">-</span></p>
                    </div>

                    <div class="modal-actions">
                        <button id="save-token-btn" class="btn-primary">Save Token</button>
                        <button id="remove-token-btn" class="btn-secondary" style="background-color: #d73a49;">Remove
                            Token</button>
                        <button id="close-settings-btn" class="btn-secondary">Close</button>
                    </div>

                    <div id="token-config-message"
                        style="margin-top: 15px; padding: 12px; border-radius: 6px; display: none;"></div>
                </div>
            </div>
        </div>

        <!-- Data Fetch Modal -->
        <div id="fetch-modal" class="modal" style="display: none;">
            <div class="modal-overlay"></div>
            <div class="modal-content">
                <h2>Fetch Workflow Data</h2>

                <!-- Configuration Section -->
                <div id="config-section">
                    <div class="form-group">
                        <label for="fetch-owner">Owner:</label>
                        <input type="text" id="fetch-owner" placeholder="e.g., project-chip">
                    </div>
                    <div class="form-group">
                        <label for="fetch-repo">Repository:</label>
                        <input type="text" id="fetch-repo" placeholder="e.g., connectedhomeip">
                    </div>
                    <div class="form-group">
                        <label for="fetch-workflow">Workflow ID:</label>
                        <input type="text" id="fetch-workflow" placeholder="e.g., tests.yaml">
                    </div>
                    <div class="form-group">
                        <label for="fetch-start-date">Start Date:</label>
                        <input type="date" id="fetch-start-date">
                    </div>
                    <div class="form-group">
                        <label for="fetch-end-date">End Date:</label>
                        <input type="date" id="fetch-end-date">
                    </div>
                    <div class="modal-actions">
                        <button id="preview-btn" class="btn-primary">Preview</button>
                        <button id="cancel-config-btn" class="btn-secondary">Cancel</button>
                    </div>
                    <div id="config-error" class="error-message" style="display: none;"></div>
                </div>

                <!-- Preview Section -->
                <div id="preview-section" style="display: none;">
                    <div class="preview-info">
                        <p id="workflow-count-text"></p>
                        <p id="date-range-text"></p>
                    </div>
                    <div class="modal-actions">
                        <button id="confirm-fetch-btn" class="btn-primary">Start Fetch</button>
                        <button id="cancel-preview-btn" class="btn-secondary">Cancel</button>
                    </div>
                    <div id="preview-error" class="error-message" style="display: none;"></div>
                </div>

                <!-- Progress Section -->
                <div id="progress-section" style="display: none;">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div id="progress-fill" class="progress-fill"></div>
                        </div>
                        <p id="progress-text" class="progress-text">Initializing...</p>
                        <p id="progress-count" class="progress-count"></p>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="results-section" style="display: none;">
                    <h3 id="results-title">Fetch Complete</h3>
                    <div id="results-summary" class="results-summary"></div>
                    <div id="results-error" class="error-message" style="display: none;"></div>
                    <div class="modal-actions">
                        <button id="close-refresh-btn" class="btn-primary">Close & Refresh</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="summary-panel">
            <div class="metric-card">
                <h3>Total Runs</h3>
                <div class="value" id="summary-total-runs">-</div>
            </div>
            <div class="metric-card">
                <h3>Overall Success Rate</h3>
                <div class="value" id="summary-success-rate">-</div>
            </div>
            <div class="metric-card">
                <h3>Overall P95 Duration
                    <span class="tooltip">
                        <span class="info-icon">?</span>
                        <span class="tooltiptext">
                            <strong>Job-Based Calculation:</strong> Duration metrics are calculated from job execution
                            times, not workflow timestamps.<br><br>
                            <strong>Why Job-Based?</strong> Workflow timestamps (created_at to updated_at) can span
                            multiple days when jobs are re-run, artificially inflating duration metrics. Job-based
                            calculation provides accurate performance insights by measuring actual CI/CD execution
                            time.<br><br>
                            <strong>Method:</strong> For each workflow, we use the maximum job duration (longest-running
                            job) as the workflow duration, then calculate P95 across all workflows.
                        </span>
                    </span>
                </h3>
                <div class="value" id="summary-p95-duration">-</div>
            </div>
        </div>

        <div class="chart-container">
            <h2>
                Workflow Run Trends
                <span class="tooltip">
                    <span class="info-icon">?</span>
                    <span class="tooltiptext">
                        <strong>P50 (Median):</strong> 50% of runs complete faster than this time<br>
                        <strong>P95:</strong> 95% of runs complete faster than this time - useful for identifying
                        outliers<br>
                        <strong>P99:</strong> 99% of runs complete faster than this time - shows worst-case
                        scenarios<br><br>
                        <strong>Note:</strong> Percentiles (P50, P95, P99) are calculated from successful runs only.
                        Average duration includes all runs (success, failure, cancelled).<br><br>
                        <strong>Job-Based Calculation:</strong> Duration metrics are based on job execution times
                        (maximum job duration per workflow), not workflow timestamps. This provides accurate performance
                        data by excluding idle time between re-runs.
                    </span>
                </span>
            </h2>
            <p class="help-text">Shows performance trends over time. Percentiles help you understand typical vs.
                worst-case performance.</p>
            <canvas id="workflow-trends-chart"></canvas>
        </div>

        <div class="chart-container">
            <h2>Workflow Run Outcomes</h2>
            <p class="help-text">Distribution of workflow run results across the selected time period.</p>
            <div class="outcomes-widget">
                <canvas id="workflow-outcomes-chart"></canvas>
            </div>
        </div>

        <div class="chart-container">
            <h2>Total Runs per Period</h2>
            <canvas id="runs-per-period-chart"></canvas>
        </div>

        <div class="chart-container" id="job-drilldown-container" style="display: none;">
            <h2 id="job-drilldown-title">Job Performance Breakdown</h2>
            <p id="job-drilldown-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="job-drilldown-chart"></canvas>
        </div>

        <div class="chart-container">
            <h2>Top 10 Slowest Jobs (by P95 Duration)
                <span class="tooltip">
                    <span class="info-icon">?</span>
                    <span class="tooltiptext">
                        Shows the top 10 jobs with the highest P95 duration for successful runs. Click on a job bar to
                        see step-level breakdown.
                    </span>
                </span>
            </h2>
            <p class="help-text">Click on any job to see detailed step performance breakdown.</p>
            <p id="slowest-jobs-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="slowest-jobs-chart"></canvas>
        </div>

        <div class="chart-container">
            <h2>Flakiness Report
                <span class="tooltip">
                    <span class="info-icon">?</span>
                    <span class="tooltiptext">
                        <strong>Flaky Jobs:</strong> Jobs that failed on first attempt but succeeded on re-run.<br><br>
                        <strong>Flakiness Score:</strong> Time-weighted metric prioritizing recent flakes (higher = more
                        problematic).<br><br>
                        <strong>Flake Rate:</strong> Percentage of runs that exhibited flaky behavior.<br><br>
                        <strong>Wasted CI Time:</strong> Total duration of failed attempts that were later re-run
                        successfully.
                    </span>
                </span>
            </h2>
            <p class="help-text">Jobs that failed on first attempt but succeeded on re-run, ranked by recency-weighted
                flakiness score.</p>
            <div id="flakiness-loading" style="text-align: center; font-style: italic; color: #586069; padding: 20px;">
                Loading flakiness data...</div>
            <div id="flakiness-error"
                style="display: none; background-color: #ffeef0; border: 1px solid #f97583; color: #d73a49; padding: 12px; border-radius: 6px; margin: 10px 0;">
            </div>
            <table id="flakiness-table" class="metrics-table"
                style="display: none; width: 100%; border-collapse: collapse; margin-top: 15px;">
                <thead>
                    <tr style="background-color: #f6f8fa; border-bottom: 2px solid #e1e4e8;">
                        <th style="padding: 12px; text-align: left; font-weight: bold; color: #24292e;">Job Name</th>
                        <th style="padding: 12px; text-align: center; font-weight: bold; color: #24292e;">Flakiness
                            Score</th>
                        <th style="padding: 12px; text-align: center; font-weight: bold; color: #24292e;">Flake Rate (%)
                        </th>
                        <th style="padding: 12px; text-align: center; font-weight: bold; color: #24292e;">Flake Count
                        </th>
                        <th style="padding: 12px; text-align: center; font-weight: bold; color: #24292e;">Total Runs
                        </th>
                        <th style="padding: 12px; text-align: center; font-weight: bold; color: #24292e;">Wasted CI Time
                        </th>
                        <th style="padding: 12px; text-align: left; font-weight: bold; color: #24292e;">Last Flaked</th>
                    </tr>
                </thead>
                <tbody id="flakiness-table-body"></tbody>
            </table>
        </div>

        <div class="chart-container" id="step-drilldown-container" style="display: none;">
            <h2 id="step-drilldown-title">Step Performance for Job</h2>
            <button id="back-to-jobs"
                style="margin-bottom: 15px; padding: 8px 16px; background-color: #586069; color: white; border: none; border-radius: 6px; cursor: pointer;">←
                Back to Jobs</button>
            <p id="step-drilldown-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="step-drilldown-chart"></canvas>
        </div>

        <div class="chart-container" id="job-trend-container" style="display: none;">
            <h2 id="job-trend-title">Job Performance Over Time</h2>
            <p id="job-trend-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="job-trend-chart"></canvas>
        </div>

        <!-- Placeholder for Chart.js library -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script>
            let trendsChart, outcomesChart, runsPerPeriodChart, jobDrilldownChart, slowestJobsChart, stepDrilldownChart, jobTrendChart;
            let currentTrendsData = [];
            let currentJobSelection = null;

            document.addEventListener('DOMContentLoaded', () => {
                const today = new Date();
                const thirtyDaysAgo = new Date(today);
                thirtyDaysAgo.setDate(today.getDate() - 30);

                document.getElementById('end-date').valueAsDate = today;
                document.getElementById('start-date').valueAsDate = thirtyDaysAgo;

                const controls = [
                    'repo-owner', 'repo-name', 'workflow-id',
                    'start-date', 'end-date', 'period'
                ];
                controls.forEach(id => {
                    document.getElementById(id).addEventListener('change', loadData);
                });
                document.getElementById('apply-filters').addEventListener('click', loadData);
                document.getElementById('export-csv').addEventListener('click', exportDataToCsv);

                document.querySelector('.preset-buttons').addEventListener('click', (event) => {
                    if (event.target.tagName === 'BUTTON' && event.target.dataset.days) {
                        const days = parseInt(event.target.dataset.days, 10);
                        if (!isNaN(days)) {
                            const endDate = new Date();
                            const startDate = new Date();
                            // setDate handles month/year rollovers correctly
                            startDate.setDate(endDate.getDate() - days);

                            document.getElementById('end-date').valueAsDate = endDate;
                            document.getElementById('start-date').valueAsDate = startDate;
                            loadData();
                        }
                    }
                });

                document.getElementById('back-to-jobs').addEventListener('click', () => {
                    document.getElementById('step-drilldown-container').style.display = 'none';
                    document.getElementById('job-trend-container').style.display = 'none';
                    currentJobSelection = null;
                });

                // Initialize modal functionality
                initializeFetchModal();
                initializeSettingsModal();

                // Check token status on load
                checkTokenStatus();

                loadData(); // Initial data load
            });

            function getSelectedConclusions() {
                const checkboxes = document.querySelectorAll('.status-checkbox:checked');
                return Array.from(checkboxes).map(cb => cb.value);
            }

            function exportDataToCsv() {
                console.log("Exporting data to CSV...");

                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const period = document.getElementById('period').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                // Convert YYYY-MM-DD to a full ISO string at the start/end of the day in UTC.
                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId) {
                    console.log("Skipping export: Owner, Repo, and Workflow ID are required.");
                    alert("Please fill in Repository Owner, Name, and Workflow ID before exporting.");
                    return;
                }

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    period,
                });

                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const csvUrl = `/api/trends.csv?${params.toString()}`;
                console.log(`Triggering download from: ${csvUrl}`);

                // This will trigger a download in the browser.
                window.location.href = csvUrl;
            }

            function formatDuration(ms) {
                if (ms === null || isNaN(ms) || ms === 0) return '-';
                if (ms < 1000) return `${Math.round(ms)}ms`;

                const seconds = ms / 1000;
                if (seconds < 60) return `${seconds.toFixed(1)}s`;

                const minutes = seconds / 60;
                if (minutes < 60) return `${minutes.toFixed(1)}m`;

                const hours = minutes / 60;
                return `${hours.toFixed(1)}h`;
            }

            function formatDurationForChart(ms) {
                if (ms === null || isNaN(ms) || ms === 0) return null;

                const seconds = ms / 1000;
                const minutes = seconds / 60;
                const hours = minutes / 60;

                // Return in the most appropriate unit
                if (hours >= 1) return hours;
                if (minutes >= 1) return minutes;
                return seconds;
            }

            function getDurationUnit(maxMs) {
                if (maxMs === null || isNaN(maxMs) || maxMs === 0) return 'seconds';

                const maxHours = maxMs / 1000 / 60 / 60;
                const maxMinutes = maxMs / 1000 / 60;

                if (maxHours >= 1) return 'hours';
                if (maxMinutes >= 1) return 'minutes';
                return 'seconds';
            }

            function renderSummaryMetrics(data, overallMetrics) {
                // Use overall metrics from backend if available, otherwise fall back to aggregating trends data
                if (overallMetrics) {
                    document.getElementById('summary-total-runs').textContent = overallMetrics.total_runs || 0;
                    document.getElementById('summary-success-rate').textContent = `${overallMetrics.success_rate || 0}%`;
                    document.getElementById('summary-p95-duration').textContent = formatDuration(overallMetrics.p95_duration_ms);
                } else {
                    // Fallback to old calculation method
                    const totalRuns = data.reduce((sum, d) => sum + (d.total_runs || 0), 0);
                    const totalSuccessfulRuns = data.reduce((sum, d) => sum + (d.successful_runs || 0), 0);

                    const successRate = totalRuns > 0 ? (totalSuccessfulRuns / totalRuns * 100).toFixed(1) : '0.0';

                    // NOTE: This is an average of per-period P95 values, not a true overall P95.
                    const p95durations = data.map(d => d.p95_duration_ms).filter(d => d !== null);
                    const avgP95 = p95durations.length > 0
                        ? p95durations.reduce((sum, d) => sum + d, 0) / p95durations.length
                        : null;

                    document.getElementById('summary-total-runs').textContent = totalRuns;
                    document.getElementById('summary-success-rate').textContent = `${successRate}%`;
                    document.getElementById('summary-p95-duration').textContent = formatDuration(avgP95);
                }
            }

            function renderTrendsChart(data) {
                if (trendsChart) {
                    trendsChart.destroy();
                }
                const ctx = document.getElementById('workflow-trends-chart').getContext('2d');
                const labels = data.map(d => d.period_start);

                // Determine the best unit based on max values
                const allDurations = data.flatMap(d => [d.avg_duration_ms, d.p50_duration_ms, d.p95_duration_ms, d.p99_duration_ms].filter(v => v !== null));
                const maxDuration = allDurations.length > 0 ? Math.max(...allDurations) : 0;
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;

                const avgDurationData = data.map(d => d.avg_duration_ms ? (d.avg_duration_ms / divisor) : null);
                const p50DurationData = data.map(d => d.p50_duration_ms ? (d.p50_duration_ms / divisor) : null);
                const p95DurationData = data.map(d => d.p95_duration_ms ? (d.p95_duration_ms / divisor) : null);
                const p99DurationData = data.map(d => d.p99_duration_ms ? (d.p99_duration_ms / divisor) : null);

                trendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Average Duration (${unit}) - All Runs`,
                            data: avgDurationData,
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.1,
                            fill: false
                        }, {
                            label: `P50 / Median (${unit}) - Successful Runs`,
                            data: p50DurationData,
                            borderColor: 'rgb(255, 159, 64)', // Orange
                            tension: 0.1,
                            fill: false,
                            borderDash: [5, 5]
                        }, {
                            label: `P95 (${unit}) - Successful Runs`,
                            data: p95DurationData,
                            borderColor: 'rgb(255, 99, 132)', // Red
                            tension: 0.1,
                            fill: false,
                            hidden: true // Hidden by default
                        }, {
                            label: `P99 (${unit}) - Successful Runs`,
                            data: p99DurationData,
                            borderColor: 'rgb(153, 102, 255)', // Purple
                            tension: 0.1,
                            fill: false,
                            hidden: true // Hidden by default
                        }]
                    },
                    options: {
                        responsive: true,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (context.parsed.y !== null) {
                                            const ms = context.parsed.y * divisor;
                                            label += ': ' + formatDuration(ms);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `Duration (${unit})`
                                }
                            }
                        }
                    }
                });
            }

            function renderOutcomesChart(data) {
                if (outcomesChart) {
                    outcomesChart.destroy();
                }
                const ctx = document.getElementById('workflow-outcomes-chart').getContext('2d');

                const totalSuccess = data.reduce((sum, d) => sum + (d.successful_runs || 0), 0);
                const totalFailure = data.reduce((sum, d) => sum + (d.failed_runs || 0), 0);
                const totalCancelled = data.reduce((sum, d) => sum + (d.cancelled_runs || 0), 0);

                outcomesChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Success', 'Failure', 'Cancelled'],
                        datasets: [{
                            label: 'Workflow Run Outcomes',
                            data: [totalSuccess, totalFailure, totalCancelled],
                            backgroundColor: [
                                'rgb(40, 167, 69)',  // Success Green
                                'rgb(220, 53, 69)',  // Failure Red
                                'rgb(255, 193, 7)'   // Cancelled Yellow/Orange
                            ],
                            hoverOffset: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }

            function renderRunsPerPeriodChart(data) {
                if (runsPerPeriodChart) {
                    runsPerPeriodChart.destroy();
                }
                const ctx = document.getElementById('runs-per-period-chart').getContext('2d');
                const labels = data.map(d => d.period_start);
                const totalRunsData = data.map(d => d.total_runs);

                runsPerPeriodChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Total Workflow Runs',
                            data: totalRunsData,
                            backgroundColor: 'rgba(54, 162, 235, 0.6)'
                        }]
                    },
                    options: {
                        responsive: true,
                        onClick: handleDrilldownClick,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            async function handleDrilldownClick(event, elements) {
                if (elements.length === 0) return;

                const index = elements[0].index;
                const periodData = currentTrendsData[index];
                if (!periodData) return;

                const periodStart = new Date(periodData.period_start + 'T00:00:00Z');
                const periodEnd = new Date(periodStart);

                const periodType = document.getElementById('period').value;
                if (periodType === 'day') {
                    // End of the same day
                    periodEnd.setUTCHours(23, 59, 59, 999);
                } else { // week
                    // 6 days after the start day, at the end of the day
                    periodEnd.setUTCDate(periodEnd.getUTCDate() + 6);
                    periodEnd.setUTCHours(23, 59, 59, 999);
                }

                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;

                const drilldownContainer = document.getElementById('job-drilldown-container');
                const drilldownTitle = document.getElementById('job-drilldown-title');
                drilldownTitle.textContent = `Job Performance for period starting ${periodData.period_start}`;
                drilldownContainer.style.display = 'block';

                // Clear previous chart/message and show loading state
                document.getElementById('job-drilldown-message').textContent = 'Loading...';
                if (jobDrilldownChart) {
                    jobDrilldownChart.destroy();
                }
                document.getElementById('job-drilldown-chart').style.display = 'none';

                await loadJobDrilldownData(owner, repo, workflowId, periodStart.toISOString(), periodEnd.toISOString());
            }

            async function loadJobDrilldownData(owner, repo, workflowId, startDate, endDate) {
                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/jobs?${params.toString()}`;
                console.log(`Fetching job drilldown from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Job drilldown data:", responseData);
                    const data = responseData.data || responseData;
                    renderJobDrilldownChart(data);
                } catch (error) {
                    console.error("Failed to load job drilldown data:", error);
                    document.getElementById('job-drilldown-message').textContent = `Error: ${error.message}`;
                }
            }

            function renderJobDrilldownChart(data) {
                const messageEl = document.getElementById('job-drilldown-message');
                const chartCanvas = document.getElementById('job-drilldown-chart');
                const ctx = chartCanvas.getContext('2d');

                if (jobDrilldownChart) {
                    jobDrilldownChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No job data available for this period.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.job_name);
                const p95durationsMs = data.map(d => d.p95_duration_ms || null);

                // Determine the best unit
                const maxDuration = p95durationsMs.filter(d => d !== null).reduce((max, d) => Math.max(max, d), 0);
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                const p95durations = p95durationsMs.map(d => d ? (d / divisor) : null);

                jobDrilldownChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `P95 Duration (${unit}) - Successful Runs`,
                            data: p95durations,
                            backgroundColor: 'rgba(153, 102, 255, 0.6)'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.x !== null) {
                                            const ms = context.parsed.x * divisor;
                                            label += formatDuration(ms);
                                        }
                                        return label;
                                    },
                                    afterLabel: function (context) {
                                        const jobData = data[context.dataIndex];
                                        return [`Total Runs: ${jobData.total_runs}`, `Success Rate: ${jobData.success_rate}%`];
                                    }
                                }
                            }
                        },
                        scales: { x: { beginAtZero: true, title: { display: true, text: `P95 Duration (${unit})` } } }
                    }
                });
            }

            async function loadSlowestJobs() {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId || !startDate || !endDate) {
                    return;
                }

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    limit: 10
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/jobs/slowest?${params.toString()}`;
                console.log(`Fetching slowest jobs from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Slowest jobs data:", responseData);
                    const data = responseData.data || responseData;
                    renderSlowestJobsChart(data);
                } catch (error) {
                    console.error("Failed to load slowest jobs:", error);
                    document.getElementById('slowest-jobs-message').textContent = `Error: ${error.message}`;
                }
            }

            function renderSlowestJobsChart(data) {
                const messageEl = document.getElementById('slowest-jobs-message');
                const chartCanvas = document.getElementById('slowest-jobs-chart');
                const ctx = chartCanvas.getContext('2d');

                if (slowestJobsChart) {
                    slowestJobsChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No job data available for the selected period.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.job_name.length > 40 ? d.job_name.substring(0, 37) + '...' : d.job_name);
                const p95durationsMs = data.map(d => d.p95_duration_ms || null);

                const maxDuration = p95durationsMs.filter(d => d !== null).reduce((max, d) => Math.max(max, d), 0);
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                const p95durations = p95durationsMs.map(d => d ? (d / divisor) : null);

                slowestJobsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `P95 Duration (${unit})`,
                            data: p95durations,
                            backgroundColor: 'rgba(255, 99, 132, 0.6)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        onClick: async (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const jobData = data[index];
                                currentJobSelection = jobData.job_name;
                                await loadStepsForJob(jobData.job_name);
                                await loadJobTrends(jobData.job_name);
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.x !== null) {
                                            const ms = context.parsed.x * divisor;
                                            label += formatDuration(ms);
                                        }
                                        return label;
                                    },
                                    afterLabel: function (context) {
                                        const jobData = data[context.dataIndex];
                                        return [`Total Runs: ${jobData.total_runs}`, `Success Rate: ${jobData.success_rate}%`];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                title: { display: true, text: `P95 Duration (${unit})` }
                            }
                        }
                    }
                });
            }

            async function loadFlakinessReport() {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId || !startDate || !endDate) {
                    return;
                }

                const loadingEl = document.getElementById('flakiness-loading');
                const errorEl = document.getElementById('flakiness-error');
                const tableEl = document.getElementById('flakiness-table');

                // Show loading state
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                tableEl.style.display = 'none';

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    limit: 10
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/jobs/flakiest?${params.toString()}`;
                console.log(`Fetching flakiness report from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const data = await response.json();
                    console.log("Flakiness report data:", data);
                    // Normalize response shape: backend may return either an array of jobs
                    // or an object with a `data` array and `metadata` field when empty.
                    const flakyJobs = Array.isArray(data) ? data : (data.data || []);
                    renderFlakinessTable(flakyJobs);
                } catch (error) {
                    console.error("Failed to load flakiness report:", error);
                    loadingEl.style.display = 'none';
                    errorEl.textContent = `Error: ${error.message}`;
                    errorEl.style.display = 'block';
                }
            }

            function renderFlakinessTable(flakyJobs) {
                const loadingEl = document.getElementById('flakiness-loading');
                const tableEl = document.getElementById('flakiness-table');
                const tbody = document.getElementById('flakiness-table-body');

                loadingEl.style.display = 'none';

                if (!flakyJobs || flakyJobs.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 20px; font-style: italic; color: #586069;">No flaky jobs detected in the selected time period.</td></tr>';
                    tableEl.style.display = 'table';
                    return;
                }

                tbody.innerHTML = '';

                flakyJobs.forEach(job => {
                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #e1e4e8';

                    // Helper function to escape HTML
                    const escapeHtml = (text) => {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };

                    row.innerHTML = `
                        <td style="padding: 12px; color: #24292e;">${escapeHtml(job.job_name)}</td>
                        <td style="padding: 12px; text-align: center; color: #24292e; font-weight: bold;">${job.flakiness_score.toFixed(1)}</td>
                        <td style="padding: 12px; text-align: center; color: #24292e;">${job.flake_rate.toFixed(1)}%</td>
                        <td style="padding: 12px; text-align: center; color: #24292e;">${job.flake_count}</td>
                        <td style="padding: 12px; text-align: center; color: #24292e;">${job.total_runs}</td>
                        <td style="padding: 12px; text-align: center; color: #24292e;">${formatDuration(job.wasted_ci_time_ms)}</td>
                        <td style="padding: 12px;">
                            <a href="${job.last_flaked_context.url}" target="_blank" style="color: #0366d6; text-decoration: none;">
                                ${escapeHtml(job.last_flaked_context.display_text)}
                            </a>
                            <br>
                            <a href="${job.last_flaked_context.job_url}" target="_blank" style="color: #586069; text-decoration: none; font-size: 0.9em;">
                                View Job →
                            </a>
                        </td>
                    `;
                    tbody.appendChild(row);
                });

                tableEl.style.display = 'table';
            }

            async function loadStepsForJob(jobName) {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                const stepContainer = document.getElementById('step-drilldown-container');
                const stepTitle = document.getElementById('step-drilldown-title');
                const messageEl = document.getElementById('step-drilldown-message');

                stepTitle.textContent = `Step Performance for: ${jobName}`;
                stepContainer.style.display = 'block';
                messageEl.textContent = 'Loading...';

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    job_name: jobName,
                    limit: 20
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/steps?${params.toString()}`;
                console.log(`Fetching steps for job from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Steps data:", responseData);
                    const data = responseData.data || responseData;
                    renderStepDrilldownChart(data);
                } catch (error) {
                    console.error("Failed to load steps:", error);
                    messageEl.textContent = `Error: ${error.message}`;
                }
            }

            function renderStepDrilldownChart(data) {
                const messageEl = document.getElementById('step-drilldown-message');
                const chartCanvas = document.getElementById('step-drilldown-chart');
                const ctx = chartCanvas.getContext('2d');

                if (stepDrilldownChart) {
                    stepDrilldownChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No step data available for this job.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.step_name.length > 50 ? d.step_name.substring(0, 47) + '...' : d.step_name);
                const avgDurationsMs = data.map(d => d.avg_success_duration_ms || d.avg_duration_ms || null);

                const maxDuration = avgDurationsMs.filter(d => d !== null).reduce((max, d) => Math.max(max, d), 0);
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                const avgDurations = avgDurationsMs.map(d => d ? (d / divisor) : null);

                stepDrilldownChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Avg Duration (${unit})`,
                            data: avgDurations,
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.x !== null) {
                                            const ms = context.parsed.x * divisor;
                                            label += formatDuration(ms);
                                        }
                                        return label;
                                    },
                                    afterLabel: function (context) {
                                        const stepData = data[context.dataIndex];
                                        return [`Total Runs: ${stepData.total_runs}`, `Success Rate: ${stepData.success_rate}%`];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                title: { display: true, text: `Avg Duration (${unit})` }
                            }
                        }
                    }
                });
            }

            async function loadJobTrends(jobName) {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const period = document.getElementById('period').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                const trendContainer = document.getElementById('job-trend-container');
                const trendTitle = document.getElementById('job-trend-title');
                const messageEl = document.getElementById('job-trend-message');

                trendTitle.textContent = `Performance Trend for: ${jobName}`;
                trendContainer.style.display = 'block';
                messageEl.textContent = 'Loading...';

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    period: period
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/jobs/${encodeURIComponent(jobName)}/trends?${params.toString()}`;
                console.log(`Fetching job trends from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Job trends data:", responseData);
                    const data = responseData.data || responseData;
                    renderJobTrendChart(data);
                } catch (error) {
                    console.error("Failed to load job trends:", error);
                    messageEl.textContent = `Error: ${error.message}`;
                }
            }

            function renderJobTrendChart(data) {
                const messageEl = document.getElementById('job-trend-message');
                const chartCanvas = document.getElementById('job-trend-chart');
                const ctx = chartCanvas.getContext('2d');

                if (jobTrendChart) {
                    jobTrendChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No trend data available for this job.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.period_start);
                const allDurations = data.flatMap(d => [d.avg_duration_ms, d.p50_duration_ms, d.p95_duration_ms].filter(v => v !== null));
                const maxDuration = allDurations.length > 0 ? Math.max(...allDurations) : 0;
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;

                const avgDurationData = data.map(d => d.avg_duration_ms ? (d.avg_duration_ms / divisor) : null);
                const p95DurationData = data.map(d => d.p95_duration_ms ? (d.p95_duration_ms / divisor) : null);

                jobTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Average Duration (${unit})`,
                            data: avgDurationData,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.1,
                            fill: true
                        }, {
                            label: `P95 Duration (${unit})`,
                            data: p95DurationData,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.1,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.dataset.label || '';
                                        if (context.parsed.y !== null) {
                                            const ms = context.parsed.y * divisor;
                                            label += ': ' + formatDuration(ms);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `Duration (${unit})`
                                }
                            }
                        }
                    }
                });
            }

            async function loadData() {
                console.log("Loading data with current filters...");
                document.getElementById('job-drilldown-container').style.display = 'none';
                document.getElementById('step-drilldown-container').style.display = 'none';
                document.getElementById('job-trend-container').style.display = 'none';

                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const period = document.getElementById('period').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                // Convert YYYY-MM-DD to a full ISO string at the start/end of the day in UTC.
                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId) {
                    console.log("Skipping API call: Owner, Repo, and Workflow ID are required.");
                    return;
                }

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    period,
                });

                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const trendsUrl = `/api/trends?${params.toString()}`;
                const overallMetricsUrl = `/api/overall-metrics?${params.toString()}`;
                console.log(`Fetching trends from: ${trendsUrl}`);
                console.log(`Fetching overall metrics from: ${overallMetricsUrl}`);

                try {
                    // Fetch both trends and overall metrics in parallel
                    const [trendsResponse, overallMetricsResponse] = await Promise.all([
                        fetch(trendsUrl),
                        fetch(overallMetricsUrl)
                    ]);

                    if (!trendsResponse.ok) {
                        const errorData = await trendsResponse.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`Trends API Error (${trendsResponse.status}): ${errorData.error || trendsResponse.statusText}`);
                    }

                    if (!overallMetricsResponse.ok) {
                        const errorData = await overallMetricsResponse.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`Overall Metrics API Error (${overallMetricsResponse.status}): ${errorData.error || overallMetricsResponse.statusText}`);
                    }

                    const trendsData = await trendsResponse.json();
                    const overallMetrics = await overallMetricsResponse.json();

                    console.log("Trends API Response Data:", trendsData);
                    console.log("Overall Metrics API Response Data:", overallMetrics);

                    // Extract the data array from the response (API returns {data: [...], metadata: {...}})
                    const data = trendsData.data || trendsData;
                    currentTrendsData = data;

                    renderSummaryMetrics(data, overallMetrics);
                    renderTrendsChart(data);
                    renderOutcomesChart(data);
                    renderRunsPerPeriodChart(data);

                    // Load slowest jobs and flakiness report
                    await loadSlowestJobs();
                    await loadFlakinessReport();
                } catch (error) {
                    console.error("Failed to load data:", error);
                }
            }

            // Modal functionality for data fetching
            function initializeFetchModal() {
                const modal = document.getElementById('fetch-modal');
                const fetchBtn = document.getElementById('fetch-data-btn');
                const previewBtn = document.getElementById('preview-btn');
                const confirmBtn = document.getElementById('confirm-fetch-btn');
                const cancelConfigBtn = document.getElementById('cancel-config-btn');
                const cancelPreviewBtn = document.getElementById('cancel-preview-btn');
                const closeRefreshBtn = document.getElementById('close-refresh-btn');

                // Open modal
                fetchBtn.addEventListener('click', async () => {
                    await openFetchModal();
                });

                // Preview workflow count
                previewBtn.addEventListener('click', async () => {
                    await previewFetch();
                });

                // Confirm and start fetch
                confirmBtn.addEventListener('click', async () => {
                    await startFetch();
                });

                // Cancel buttons
                cancelConfigBtn.addEventListener('click', () => {
                    closeFetchModal();
                });

                cancelPreviewBtn.addEventListener('click', () => {
                    showModalSection('config');
                });

                // Close and refresh
                closeRefreshBtn.addEventListener('click', () => {
                    closeFetchModal();
                    loadData(); // Refresh dashboard data
                });

                // Close modal when clicking overlay
                modal.querySelector('.modal-overlay').addEventListener('click', () => {
                    closeFetchModal();
                });
            }

            async function openFetchModal() {
                const modal = document.getElementById('fetch-modal');

                // Load default configuration
                try {
                    const response = await fetch('/api/config');
                    if (response.ok) {
                        const config = await response.json();
                        document.getElementById('fetch-owner').value = config.owner || '';
                        document.getElementById('fetch-repo').value = config.repo || '';
                        document.getElementById('fetch-workflow').value = config.workflow_id || '';
                    }
                } catch (error) {
                    console.error('Failed to load config:', error);
                }

                // Set default dates (last 7 days)
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(endDate.getDate() - 7);

                document.getElementById('fetch-end-date').valueAsDate = endDate;
                document.getElementById('fetch-start-date').valueAsDate = startDate;

                // Show modal and config section
                showModalSection('config');
                modal.style.display = 'block';
            }

            function closeFetchModal() {
                const modal = document.getElementById('fetch-modal');
                modal.style.display = 'none';

                // Clear any error messages
                hideError('config-error');
                hideError('preview-error');
                hideError('results-error');
            }

            function showModalSection(section) {
                const sections = ['config', 'preview', 'progress', 'results'];
                sections.forEach(s => {
                    const element = document.getElementById(`${s}-section`);
                    element.style.display = s === section ? 'block' : 'none';
                });
            }

            function showError(elementId, message, errorType) {
                const errorElement = document.getElementById(elementId);

                // Format error message based on type
                let formattedMessage = message;

                if (errorType === 'authentication') {
                    formattedMessage = `<strong>Authentication Error:</strong><br>${message}`;
                    if (message.includes('not configured') || message.includes('missing')) {
                        formattedMessage += '<br><br><em>To fix this: Set GITHUB_TOKEN in your .env file</em>';
                    } else if (message.includes('invalid') || message.includes('expired')) {
                        formattedMessage += '<br><br><em>To fix this: Generate a new GitHub personal access token with repo or actions:read scope</em>';
                    } else if (message.includes('permissions') || message.includes('Forbidden')) {
                        formattedMessage += '<br><br><em>To fix this: Ensure your token has repo or actions:read scope</em>';
                    }
                } else if (errorType === 'validation') {
                    formattedMessage = `<strong>Validation Error:</strong><br>${message}`;
                } else if (errorType === 'api') {
                    formattedMessage = `<strong>API Error:</strong><br>${message}`;
                } else {
                    formattedMessage = `<strong>Error:</strong><br>${message}`;
                }

                errorElement.innerHTML = formattedMessage;
                errorElement.style.display = 'block';
            }

            function hideError(elementId) {
                const errorElement = document.getElementById(elementId);
                errorElement.style.display = 'none';
                errorElement.innerHTML = '';
            }

            function validateFetchInputs() {
                const owner = document.getElementById('fetch-owner').value.trim();
                const repo = document.getElementById('fetch-repo').value.trim();
                const workflowId = document.getElementById('fetch-workflow').value.trim();
                const startDate = document.getElementById('fetch-start-date').value;
                const endDate = document.getElementById('fetch-end-date').value;

                // Check for missing fields
                const missingFields = [];
                if (!owner) missingFields.push('Owner');
                if (!repo) missingFields.push('Repository');
                if (!workflowId) missingFields.push('Workflow ID');

                if (missingFields.length > 0) {
                    return {
                        valid: false,
                        error: `Missing required field${missingFields.length > 1 ? 's' : ''}: ${missingFields.join(', ')}`,
                        errorType: 'validation'
                    };
                }

                if (!startDate || !endDate) {
                    return {
                        valid: false,
                        error: 'Please select both start and end dates',
                        errorType: 'validation'
                    };
                }

                // Validate date format and range
                const start = new Date(startDate);
                const end = new Date(endDate);

                if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                    return {
                        valid: false,
                        error: 'Invalid date format. Please select valid dates.',
                        errorType: 'validation'
                    };
                }

                if (end <= start) {
                    return {
                        valid: false,
                        error: 'End date must be after start date',
                        errorType: 'validation'
                    };
                }

                // Check if date range is reasonable (not too far in the future)
                const now = new Date();
                if (start > now) {
                    return {
                        valid: false,
                        error: 'Start date cannot be in the future',
                        errorType: 'validation'
                    };
                }

                return { valid: true };
            }

            async function previewFetch() {
                hideError('config-error');

                const validation = validateFetchInputs();
                if (!validation.valid) {
                    showError('config-error', validation.error, validation.errorType || 'validation');
                    return;
                }

                const owner = document.getElementById('fetch-owner').value.trim();
                const repo = document.getElementById('fetch-repo').value.trim();
                const workflowId = document.getElementById('fetch-workflow').value.trim();
                const startDate = document.getElementById('fetch-start-date').value;
                const endDate = document.getElementById('fetch-end-date').value;

                // Disable preview button
                const previewBtn = document.getElementById('preview-btn');
                previewBtn.disabled = true;
                previewBtn.textContent = 'Loading...';

                try {
                    const response = await fetch('/api/fetch/preview', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            owner,
                            repo,
                            workflow_id: workflowId,
                            start_date: new Date(startDate).toISOString(),
                            end_date: new Date(endDate).toISOString()
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || `Server error: ${response.status}`);
                    }

                    // Display preview information
                    const countSuffix = data.workflow_count !== 1 ? 's' : '';
                    const estimatePrefix = data.is_estimate ? '~' : '';
                    document.getElementById('workflow-count-text').textContent =
                        `Found ${estimatePrefix}${data.workflow_count} workflow run${countSuffix} in this period`;

                    const startFormatted = new Date(data.date_range.start).toLocaleDateString();
                    const endFormatted = new Date(data.date_range.end).toLocaleDateString();
                    let dateRangeText = `Date range: ${startFormatted} to ${endFormatted}`;

                    if (data.note) {
                        dateRangeText += `\n\n${data.note}`;
                    }

                    document.getElementById('date-range-text').textContent = dateRangeText;

                    showModalSection('preview');

                } catch (error) {
                    console.error('Preview failed:', error);

                    // Parse error response if available
                    let errorMessage = error.message;
                    let errorType = 'internal';

                    // Try to extract error details from response
                    try {
                        const errorData = JSON.parse(error.message);
                        if (errorData.error) {
                            errorMessage = errorData.error;
                            errorType = errorData.error_type || 'internal';
                            if (errorData.details) {
                                errorMessage += ': ' + errorData.details;
                            }
                        }
                    } catch (e) {
                        // Not JSON, use original message
                        // Determine error type from message content
                        if (errorMessage.includes('401') || errorMessage.includes('authentication') ||
                            errorMessage.includes('token not configured') || errorMessage.includes('token is missing')) {
                            errorType = 'authentication';
                            errorMessage = 'GitHub token not configured';
                        } else if (errorMessage.includes('403') || errorMessage.includes('Forbidden') ||
                            errorMessage.includes('permissions')) {
                            errorType = 'authentication';
                            errorMessage = 'Insufficient GitHub API permissions';
                        } else if (errorMessage.includes('404')) {
                            errorType = 'validation';
                            errorMessage = 'Repository or workflow not found. Please check your inputs.';
                        } else if (errorMessage.includes('Invalid date') || errorMessage.includes('date range')) {
                            errorType = 'validation';
                        } else if (errorMessage.includes('Missing required')) {
                            errorType = 'validation';
                        }
                    }

                    showError('config-error', errorMessage, errorType);
                } finally {
                    previewBtn.disabled = false;
                    previewBtn.textContent = 'Preview';
                }
            }

            async function startFetch() {
                hideError('preview-error');

                const owner = document.getElementById('fetch-owner').value.trim();
                const repo = document.getElementById('fetch-repo').value.trim();
                const workflowId = document.getElementById('fetch-workflow').value.trim();
                const startDate = document.getElementById('fetch-start-date').value;
                const endDate = document.getElementById('fetch-end-date').value;

                // Disable confirm button
                const confirmBtn = document.getElementById('confirm-fetch-btn');
                confirmBtn.disabled = true;
                confirmBtn.textContent = 'Starting...';

                try {
                    const response = await fetch('/api/fetch/start', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            owner,
                            repo,
                            workflow_id: workflowId,
                            start_date: new Date(startDate).toISOString(),
                            end_date: new Date(endDate).toISOString()
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || `Server error: ${response.status}`);
                    }

                    // Show progress section and start polling
                    showModalSection('progress');
                    pollFetchStatus(data.task_id);

                } catch (error) {
                    console.error('Failed to start fetch:', error);

                    // Parse error response
                    let errorMessage = error.message;
                    let errorType = 'internal';

                    try {
                        const errorData = JSON.parse(error.message);
                        if (errorData.error) {
                            errorMessage = errorData.error;
                            errorType = errorData.error_type || 'internal';
                            if (errorData.details) {
                                errorMessage += ': ' + errorData.details;
                            }
                        }
                    } catch (e) {
                        // Determine error type from message
                        if (errorMessage.includes('authentication') || errorMessage.includes('token')) {
                            errorType = 'authentication';
                        } else if (errorMessage.includes('validation') || errorMessage.includes('Invalid')) {
                            errorType = 'validation';
                        }
                    }

                    showError('preview-error', errorMessage, errorType);
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'Start Fetch';
                }
            }

            let pollInterval = null;

            function pollFetchStatus(taskId) {
                // Clear any existing polling
                if (pollInterval) {
                    clearInterval(pollInterval);
                }

                // Initial status check
                checkFetchStatus(taskId);

                // Poll every 2 seconds
                pollInterval = setInterval(() => {
                    checkFetchStatus(taskId);
                }, 2000);
            }

            async function checkFetchStatus(taskId) {
                try {
                    const response = await fetch(`/api/fetch/status/${taskId}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to get task status');
                    }

                    if (data.status === 'in_progress' || data.status === 'pending') {
                        updateProgress(data.progress);
                    } else if (data.status === 'completed') {
                        // Stop polling
                        if (pollInterval) {
                            clearInterval(pollInterval);
                            pollInterval = null;
                        }
                        showResults(data.result, false);
                    } else if (data.status === 'failed') {
                        // Stop polling
                        if (pollInterval) {
                            clearInterval(pollInterval);
                            pollInterval = null;
                        }
                        showResults(data.result, true, data.error);
                    }

                } catch (error) {
                    console.error('Failed to check status:', error);
                    // Stop polling on error
                    if (pollInterval) {
                        clearInterval(pollInterval);
                        pollInterval = null;
                    }
                    showResults(null, true, error.message);
                }
            }

            function updateProgress(progress) {
                if (!progress) {
                    document.getElementById('progress-text').textContent = 'Initializing...';
                    document.getElementById('progress-count').textContent = '';
                    document.getElementById('progress-fill').style.width = '0%';
                    return;
                }

                const { current, total, message } = progress;

                // Update progress bar
                const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
                document.getElementById('progress-fill').style.width = `${percentage}%`;

                // Update progress text
                document.getElementById('progress-text').textContent = message || 'Processing...';

                // Update count
                if (current !== undefined && total !== undefined) {
                    document.getElementById('progress-count').textContent =
                        `Workflow ${current} of ${total}`;
                }
            }

            function showResults(result, isError, errorMessage) {
                showModalSection('results');

                if (isError) {
                    // Show error state
                    document.getElementById('results-title').textContent = 'Fetch Failed';
                    document.getElementById('results-summary').innerHTML = '';

                    const errorText = errorMessage || 'An unknown error occurred during the fetch operation.';
                    showError('results-error', errorText);
                } else {
                    // Show success state
                    document.getElementById('results-title').textContent = 'Fetch Complete';
                    hideError('results-error');

                    // Build results summary
                    const summaryHtml = `
                        <p><strong>Runs Collected:</strong> ${result.runs_collected || 0}</p>
                        <p><strong>Runs Skipped:</strong> ${result.runs_skipped || 0} (already in database)</p>
                        ${result.incomplete_runs_stored !== undefined ?
                            `<p><strong>Incomplete Runs Stored:</strong> ${result.incomplete_runs_stored}</p>` : ''}
                        ${result.incomplete_runs_skipped !== undefined ?
                            `<p><strong>Incomplete Runs Skipped:</strong> ${result.incomplete_runs_skipped}</p>` : ''}
                        ${result.errors && result.errors.length > 0 ?
                            `<p style="color: #d73a49;"><strong>Errors:</strong> ${result.errors.length} error(s) encountered</p>` :
                            '<p style="color: #2ea44f;"><strong>Status:</strong> Completed successfully</p>'}
                    `;

                    document.getElementById('results-summary').innerHTML = summaryHtml;

                    // Show error details if any
                    if (result.errors && result.errors.length > 0) {
                        const errorDetails = result.errors.slice(0, 5).join('\n');
                        const moreErrors = result.errors.length > 5 ?
                            `\n... and ${result.errors.length - 5} more error(s)` : '';
                        showError('results-error', `Errors encountered:\n${errorDetails}${moreErrors}`);
                    }
                }
            }

            // Settings Modal Functions
            function initializeSettingsModal() {
                const settingsBtn = document.getElementById('settings-btn');
                const settingsModal = document.getElementById('settings-modal');
                const closeSettingsBtn = document.getElementById('close-settings-btn');
                const saveTokenBtn = document.getElementById('save-token-btn');
                const removeTokenBtn = document.getElementById('remove-token-btn');
                const modalOverlay = settingsModal.querySelector('.modal-overlay');

                // Open settings modal
                settingsBtn.addEventListener('click', () => {
                    settingsModal.style.display = 'block';
                    updateTokenStatusInfo();
                    document.getElementById('github-token-input').value = '';
                    hideTokenMessage();
                });

                // Close settings modal
                closeSettingsBtn.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                    hideTokenMessage();
                });

                modalOverlay.addEventListener('click', () => {
                    settingsModal.style.display = 'none';
                    hideTokenMessage();
                });

                // Save token
                saveTokenBtn.addEventListener('click', async () => {
                    const token = document.getElementById('github-token-input').value.trim();

                    if (!token) {
                        showTokenMessage('Please enter a GitHub token', 'error');
                        return;
                    }

                    // Disable button during save
                    saveTokenBtn.disabled = true;
                    saveTokenBtn.textContent = 'Saving...';

                    try {
                        const response = await fetch('/api/config/token', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ token })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            showTokenMessage('Token saved successfully!', 'success');
                            document.getElementById('github-token-input').value = '';
                            updateTokenStatusInfo();
                            checkTokenStatus();
                        } else {
                            showTokenMessage(data.error || 'Failed to save token', 'error');
                        }
                    } catch (error) {
                        showTokenMessage('Network error: ' + error.message, 'error');
                    } finally {
                        saveTokenBtn.disabled = false;
                        saveTokenBtn.textContent = 'Save Token';
                    }
                });

                // Remove token
                removeTokenBtn.addEventListener('click', async () => {
                    if (!confirm('Are you sure you want to remove the stored GitHub token?')) {
                        return;
                    }

                    removeTokenBtn.disabled = true;
                    removeTokenBtn.textContent = 'Removing...';

                    try {
                        const response = await fetch('/api/config/token', {
                            method: 'DELETE'
                        });

                        const data = await response.json();

                        if (response.ok) {
                            showTokenMessage('Token removed successfully', 'success');
                            updateTokenStatusInfo();
                            checkTokenStatus();
                        } else {
                            showTokenMessage(data.error || 'Failed to remove token', 'error');
                        }
                    } catch (error) {
                        showTokenMessage('Network error: ' + error.message, 'error');
                    } finally {
                        removeTokenBtn.disabled = false;
                        removeTokenBtn.textContent = 'Remove Token';
                    }
                });
            }

            async function checkTokenStatus() {
                try {
                    const response = await fetch('/api/config/token/status');
                    const data = await response.json();

                    const indicator = document.getElementById('token-indicator');
                    const text = document.getElementById('token-text');

                    if (data.configured && data.valid) {
                        indicator.style.backgroundColor = '#2ea44f'; // Green
                        text.textContent = `Token configured (${data.source})`;
                    } else if (data.configured && !data.valid) {
                        indicator.style.backgroundColor = '#d73a49'; // Red
                        text.textContent = `Token invalid (${data.source})`;
                    } else {
                        indicator.style.backgroundColor = '#ffa500'; // Orange
                        text.textContent = 'No token configured';
                    }
                } catch (error) {
                    console.error('Failed to check token status:', error);
                    const indicator = document.getElementById('token-indicator');
                    const text = document.getElementById('token-text');
                    indicator.style.backgroundColor = '#6c757d'; // Gray
                    text.textContent = 'Status unknown';
                }
            }

            async function updateTokenStatusInfo() {
                try {
                    const response = await fetch('/api/config/token/status');
                    const data = await response.json();

                    const statusText = data.configured ?
                        (data.valid ? '✓ Configured and valid' : '✗ Configured but invalid') :
                        '✗ Not configured';

                    const sourceText = data.source === 'environment' ? 'Environment variable' :
                        data.source === 'stored' ? 'Stored (encrypted)' :
                            'None';

                    document.getElementById('current-token-status').textContent = statusText;
                    document.getElementById('current-token-source').textContent = sourceText;
                } catch (error) {
                    console.error('Failed to update token status:', error);
                    document.getElementById('current-token-status').textContent = 'Error checking status';
                    document.getElementById('current-token-source').textContent = '-';
                }
            }

            function showTokenMessage(message, type) {
                const messageDiv = document.getElementById('token-config-message');
                messageDiv.textContent = message;
                messageDiv.style.display = 'block';

                if (type === 'success') {
                    messageDiv.style.backgroundColor = '#d4edda';
                    messageDiv.style.borderColor = '#c3e6cb';
                    messageDiv.style.color = '#155724';
                } else {
                    messageDiv.style.backgroundColor = '#ffeef0';
                    messageDiv.style.borderColor = '#f97583';
                    messageDiv.style.color = '#d73a49';
                }
            }

            function hideTokenMessage() {
                const messageDiv = document.getElementById('token-config-message');
                messageDiv.style.display = 'none';
            }
        </script>
    </div>
</body>

</html>