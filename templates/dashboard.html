<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Actions Performance Dashboard</title>
    <style>
        /* Basic CSS for layout and visibility */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        header {
            background-color: #24292e; /* GitHub dark header color */
            color: #fff;
            padding: 15px 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
            margin-bottom: 20px;
        }
        header h1 {
            margin: 0;
            font-size: 1.8em;
        }
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding: 15px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #f6f8fa;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 180px;
        }
        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #586069;
            font-size: 0.9em;
        }
        .control-group select,
        .control-group input[type="date"],
        .control-group button {
            padding: 8px 10px;
            border: 1px solid #d1d5da;
            border-radius: 6px;
            font-size: 1em;
            background-color: #fff;
        }
        .status-filter {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .status-filter label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            color: #24292e;
            cursor: pointer;
        }
        .status-filter input[type="checkbox"] {
            cursor: pointer;
        }
        .control-group button {
            background-color: #2ea44f; /* GitHub green button */
            color: #fff;
            cursor: pointer;
            border: none;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }
        .control-group button:hover {
            background-color: #2c974b;
        }
        .preset-buttons {
            display: flex;
            gap: 5px;
        }
        .summary-panel {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        .metric-card {
            background-color: #f6f8fa;
            padding: 20px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            flex-grow: 1;
        }
        .metric-card h3 {
            margin: 0 0 10px 0;
            color: #586069;
            font-size: 1em;
            text-transform: uppercase;
        }
        .metric-card .value {
            font-size: 2em;
            font-weight: bold;
            color: #24292e;
        }
        .chart-container {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }
        .chart-container h2 {
            margin-top: 0;
            color: #24292e;
            font-size: 1.4em;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .chart-container .help-text {
            color: #586069;
            font-size: 0.9em;
            margin-top: -10px;
            margin-bottom: 15px;
            font-style: italic;
        }
        .outcomes-widget {
            max-width: 400px;
            margin: 0 auto;
        }
        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background-color: #0366d6;
            color: white;
            border-radius: 50%;
            text-align: center;
            font-size: 12px;
            line-height: 16px;
            cursor: help;
            margin-left: 5px;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #24292e;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85em;
            line-height: 1.4;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .chart-placeholder {
            width: 100%;
            height: 300px; /* Placeholder height for charts */
            background-color: #f0f0f0;
            border: 1px dashed #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>GitHub Actions Performance Dashboard</h1>
        </header>

        <div class="control-panel">
            <div class="control-group">
                <label for="repo-owner">Repository Owner:</label>
                <input type="text" id="repo-owner" value="project-chip">
            </div>
            <div class="control-group">
                <label for="repo-name">Repository Name:</label>
                <input type="text" id="repo-name" value="connectedhomeip">
            </div>
            <div class="control-group">
                <label for="workflow-id">Workflow ID:</label>
                <input type="text" id="workflow-id" value="tests.yaml">
            </div>
            <div class="control-group">
                <label for="start-date">Start Date:</label>
                <input type="date" id="start-date">
            </div>
            <div class="control-group">
                <label for="end-date">End Date:</label>
                <input type="date" id="end-date">
            </div>
            <div class="control-group">
                <label>Presets:</label>
                <div class="preset-buttons">
                    <button data-days="7">Last 7 Days</button>
                    <button data-days="30">Last 30 Days</button>
                    <button data-days="90">Last 90 Days</button>
                </div>
            </div>
            <div class="control-group">
                <label for="period">Group By:</label>
                <select id="period">
                    <option value="day">Day</option>
                    <option value="week">Week</option>
                </select>
            </div>
            <div class="control-group">
                <label style="font-weight: bold;">Workflow Status:</label>
                <div class="status-filter">
                    <label><input type="checkbox" class="status-checkbox" value="success" checked> Success</label>
                    <label><input type="checkbox" class="status-checkbox" value="failure" checked> Failure</label>
                    <label><input type="checkbox" class="status-checkbox" value="cancelled" checked> Cancelled</label>
                    <label><input type="checkbox" class="status-checkbox" value="skipped" checked> Skipped</label>
                    <label><input type="checkbox" class="status-checkbox" value="action_required" checked> Action Required</label>
                </div>
            </div>
            <div class="control-group">
                <label>&nbsp;</label> <!-- Placeholder for alignment -->
                <button id="apply-filters">Apply Filters</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label> <!-- Placeholder for alignment -->
                <button id="export-csv">Export to CSV</button>
            </div>
        </div>

        <div class="summary-panel">
            <div class="metric-card">
                <h3>Total Runs</h3>
                <div class="value" id="summary-total-runs">-</div>
            </div>
            <div class="metric-card">
                <h3>Overall Success Rate</h3>
                <div class="value" id="summary-success-rate">-</div>
            </div>
            <div class="metric-card">
                <h3>Overall P95 Duration
                    <span class="tooltip">
                        <span class="info-icon">?</span>
                        <span class="tooltiptext">
                            <strong>Job-Based Calculation:</strong> Duration metrics are calculated from job execution times, not workflow timestamps.<br><br>
                            <strong>Why Job-Based?</strong> Workflow timestamps (created_at to updated_at) can span multiple days when jobs are re-run, artificially inflating duration metrics. Job-based calculation provides accurate performance insights by measuring actual CI/CD execution time.<br><br>
                            <strong>Method:</strong> For each workflow, we use the maximum job duration (longest-running job) as the workflow duration, then calculate P95 across all workflows.
                        </span>
                    </span>
                </h3>
                <div class="value" id="summary-p95-duration">-</div>
            </div>
        </div>

        <div class="chart-container">
            <h2>
                Workflow Run Trends
                <span class="tooltip">
                    <span class="info-icon">?</span>
                    <span class="tooltiptext">
                        <strong>P50 (Median):</strong> 50% of runs complete faster than this time<br>
                        <strong>P95:</strong> 95% of runs complete faster than this time - useful for identifying outliers<br>
                        <strong>P99:</strong> 99% of runs complete faster than this time - shows worst-case scenarios<br><br>
                        <strong>Note:</strong> Percentiles (P50, P95, P99) are calculated from successful runs only. Average duration includes all runs (success, failure, cancelled).<br><br>
                        <strong>Job-Based Calculation:</strong> Duration metrics are based on job execution times (maximum job duration per workflow), not workflow timestamps. This provides accurate performance data by excluding idle time between re-runs.
                    </span>
                </span>
            </h2>
            <p class="help-text">Shows performance trends over time. Percentiles help you understand typical vs. worst-case performance.</p>
            <canvas id="workflow-trends-chart"></canvas>
        </div>

        <div class="chart-container">
            <h2>Workflow Run Outcomes</h2>
            <p class="help-text">Distribution of workflow run results across the selected time period.</p>
            <div class="outcomes-widget">
                <canvas id="workflow-outcomes-chart"></canvas>
            </div>
        </div>

        <div class="chart-container">
            <h2>Total Runs per Period</h2>
            <canvas id="runs-per-period-chart"></canvas>
        </div>

        <div class="chart-container" id="job-drilldown-container" style="display: none;">
            <h2 id="job-drilldown-title">Job Performance Breakdown</h2>
            <p id="job-drilldown-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="job-drilldown-chart"></canvas>
        </div>

        <div class="chart-container">
            <h2>Top 10 Slowest Jobs (by P95 Duration)
                <span class="tooltip">
                    <span class="info-icon">?</span>
                    <span class="tooltiptext">
                        Shows the top 10 jobs with the highest P95 duration for successful runs. Click on a job bar to see step-level breakdown.
                    </span>
                </span>
            </h2>
            <p class="help-text">Click on any job to see detailed step performance breakdown.</p>
            <p id="slowest-jobs-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="slowest-jobs-chart"></canvas>
        </div>

        <div class="chart-container" id="step-drilldown-container" style="display: none;">
            <h2 id="step-drilldown-title">Step Performance for Job</h2>
            <button id="back-to-jobs" style="margin-bottom: 15px; padding: 8px 16px; background-color: #586069; color: white; border: none; border-radius: 6px; cursor: pointer;">‚Üê Back to Jobs</button>
            <p id="step-drilldown-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="step-drilldown-chart"></canvas>
        </div>

        <div class="chart-container" id="job-trend-container" style="display: none;">
            <h2 id="job-trend-title">Job Performance Over Time</h2>
            <p id="job-trend-message" style="text-align: center; font-style: italic; color: #586069;"></p>
            <canvas id="job-trend-chart"></canvas>
        </div>

        <!-- Placeholder for Chart.js library -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script>
            let trendsChart, outcomesChart, runsPerPeriodChart, jobDrilldownChart, slowestJobsChart, stepDrilldownChart, jobTrendChart;
            let currentTrendsData = [];
            let currentJobSelection = null;

            document.addEventListener('DOMContentLoaded', () => {
                const today = new Date();
                const thirtyDaysAgo = new Date(today);
                thirtyDaysAgo.setDate(today.getDate() - 30);

                document.getElementById('end-date').valueAsDate = today;
                document.getElementById('start-date').valueAsDate = thirtyDaysAgo;

                const controls = [
                    'repo-owner', 'repo-name', 'workflow-id',
                    'start-date', 'end-date', 'period'
                ];
                controls.forEach(id => {
                    document.getElementById(id).addEventListener('change', loadData);
                });
                document.getElementById('apply-filters').addEventListener('click', loadData);
                document.getElementById('export-csv').addEventListener('click', exportDataToCsv);

                document.querySelector('.preset-buttons').addEventListener('click', (event) => {
                    if (event.target.tagName === 'BUTTON' && event.target.dataset.days) {
                        const days = parseInt(event.target.dataset.days, 10);
                        if (!isNaN(days)) {
                            const endDate = new Date();
                            const startDate = new Date();
                            // setDate handles month/year rollovers correctly
                            startDate.setDate(endDate.getDate() - days);

                            document.getElementById('end-date').valueAsDate = endDate;
                            document.getElementById('start-date').valueAsDate = startDate;
                            loadData();
                        }
                    }
                });

                document.getElementById('back-to-jobs').addEventListener('click', () => {
                    document.getElementById('step-drilldown-container').style.display = 'none';
                    document.getElementById('job-trend-container').style.display = 'none';
                    currentJobSelection = null;
                });

                loadData(); // Initial data load
            });

            function getSelectedConclusions() {
                const checkboxes = document.querySelectorAll('.status-checkbox:checked');
                return Array.from(checkboxes).map(cb => cb.value);
            }

            function exportDataToCsv() {
                console.log("Exporting data to CSV...");

                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const period = document.getElementById('period').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                // Convert YYYY-MM-DD to a full ISO string at the start/end of the day in UTC.
                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId) {
                    console.log("Skipping export: Owner, Repo, and Workflow ID are required.");
                    alert("Please fill in Repository Owner, Name, and Workflow ID before exporting.");
                    return;
                }

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    period,
                });

                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);
                
                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const csvUrl = `/api/trends.csv?${params.toString()}`;
                console.log(`Triggering download from: ${csvUrl}`);

                // This will trigger a download in the browser.
                window.location.href = csvUrl;
            }

            function formatDuration(ms) {
                if (ms === null || isNaN(ms) || ms === 0) return '-';
                if (ms < 1000) return `${Math.round(ms)}ms`;
                
                const seconds = ms / 1000;
                if (seconds < 60) return `${seconds.toFixed(1)}s`;
                
                const minutes = seconds / 60;
                if (minutes < 60) return `${minutes.toFixed(1)}m`;
                
                const hours = minutes / 60;
                return `${hours.toFixed(1)}h`;
            }

            function formatDurationForChart(ms) {
                if (ms === null || isNaN(ms) || ms === 0) return null;
                
                const seconds = ms / 1000;
                const minutes = seconds / 60;
                const hours = minutes / 60;
                
                // Return in the most appropriate unit
                if (hours >= 1) return hours;
                if (minutes >= 1) return minutes;
                return seconds;
            }

            function getDurationUnit(maxMs) {
                if (maxMs === null || isNaN(maxMs) || maxMs === 0) return 'seconds';
                
                const maxHours = maxMs / 1000 / 60 / 60;
                const maxMinutes = maxMs / 1000 / 60;
                
                if (maxHours >= 1) return 'hours';
                if (maxMinutes >= 1) return 'minutes';
                return 'seconds';
            }

            function renderSummaryMetrics(data, overallMetrics) {
                // Use overall metrics from backend if available, otherwise fall back to aggregating trends data
                if (overallMetrics) {
                    document.getElementById('summary-total-runs').textContent = overallMetrics.total_runs || 0;
                    document.getElementById('summary-success-rate').textContent = `${overallMetrics.success_rate || 0}%`;
                    document.getElementById('summary-p95-duration').textContent = formatDuration(overallMetrics.p95_duration_ms);
                } else {
                    // Fallback to old calculation method
                    const totalRuns = data.reduce((sum, d) => sum + (d.total_runs || 0), 0);
                    const totalSuccessfulRuns = data.reduce((sum, d) => sum + (d.successful_runs || 0), 0);
                    
                    const successRate = totalRuns > 0 ? (totalSuccessfulRuns / totalRuns * 100).toFixed(1) : '0.0';

                    // NOTE: This is an average of per-period P95 values, not a true overall P95.
                    const p95durations = data.map(d => d.p95_duration_ms).filter(d => d !== null);
                    const avgP95 = p95durations.length > 0 
                        ? p95durations.reduce((sum, d) => sum + d, 0) / p95durations.length
                        : null;

                    document.getElementById('summary-total-runs').textContent = totalRuns;
                    document.getElementById('summary-success-rate').textContent = `${successRate}%`;
                    document.getElementById('summary-p95-duration').textContent = formatDuration(avgP95);
                }
            }

            function renderTrendsChart(data) {
                if (trendsChart) {
                    trendsChart.destroy();
                }
                const ctx = document.getElementById('workflow-trends-chart').getContext('2d');
                const labels = data.map(d => d.period_start);
                
                // Determine the best unit based on max values
                const allDurations = data.flatMap(d => [d.avg_duration_ms, d.p50_duration_ms, d.p95_duration_ms, d.p99_duration_ms].filter(v => v !== null));
                const maxDuration = allDurations.length > 0 ? Math.max(...allDurations) : 0;
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                
                const avgDurationData = data.map(d => d.avg_duration_ms ? (d.avg_duration_ms / divisor) : null);
                const p50DurationData = data.map(d => d.p50_duration_ms ? (d.p50_duration_ms / divisor) : null);
                const p95DurationData = data.map(d => d.p95_duration_ms ? (d.p95_duration_ms / divisor) : null);
                const p99DurationData = data.map(d => d.p99_duration_ms ? (d.p99_duration_ms / divisor) : null);

                trendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Average Duration (${unit}) - All Runs`,
                            data: avgDurationData,
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.1,
                            fill: false
                        }, {
                            label: `P50 / Median (${unit}) - Successful Runs`,
                            data: p50DurationData,
                            borderColor: 'rgb(255, 159, 64)', // Orange
                            tension: 0.1,
                            fill: false,
                            borderDash: [5, 5]
                        }, {
                            label: `P95 (${unit}) - Successful Runs`,
                            data: p95DurationData,
                            borderColor: 'rgb(255, 99, 132)', // Red
                            tension: 0.1,
                            fill: false,
                            hidden: true // Hidden by default
                        }, {
                            label: `P99 (${unit}) - Successful Runs`,
                            data: p99DurationData,
                            borderColor: 'rgb(153, 102, 255)', // Purple
                            tension: 0.1,
                            fill: false,
                            hidden: true // Hidden by default
                        }]
                    },
                    options: {
                        responsive: true,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (context.parsed.y !== null) {
                                            const ms = context.parsed.y * divisor;
                                            label += ': ' + formatDuration(ms);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `Duration (${unit})`
                                }
                            }
                        }
                    }
                });
            }

            function renderOutcomesChart(data) {
                if (outcomesChart) {
                    outcomesChart.destroy();
                }
                const ctx = document.getElementById('workflow-outcomes-chart').getContext('2d');
                
                const totalSuccess = data.reduce((sum, d) => sum + (d.successful_runs || 0), 0);
                const totalFailure = data.reduce((sum, d) => sum + (d.failed_runs || 0), 0);
                const totalCancelled = data.reduce((sum, d) => sum + (d.cancelled_runs || 0), 0);

                outcomesChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Success', 'Failure', 'Cancelled'],
                        datasets: [{
                            label: 'Workflow Run Outcomes',
                            data: [totalSuccess, totalFailure, totalCancelled],
                            backgroundColor: [
                                'rgb(40, 167, 69)',  // Success Green
                                'rgb(220, 53, 69)',  // Failure Red
                                'rgb(255, 193, 7)'   // Cancelled Yellow/Orange
                            ],
                            hoverOffset: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }

            function renderRunsPerPeriodChart(data) {
                if (runsPerPeriodChart) {
                    runsPerPeriodChart.destroy();
                }
                const ctx = document.getElementById('runs-per-period-chart').getContext('2d');
                const labels = data.map(d => d.period_start);
                const totalRunsData = data.map(d => d.total_runs);

                runsPerPeriodChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Total Workflow Runs',
                            data: totalRunsData,
                            backgroundColor: 'rgba(54, 162, 235, 0.6)'
                        }]
                    },
                    options: {
                        responsive: true,
                        onClick: handleDrilldownClick,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            async function handleDrilldownClick(event, elements) {
                if (elements.length === 0) return;

                const index = elements[0].index;
                const periodData = currentTrendsData[index];
                if (!periodData) return;

                const periodStart = new Date(periodData.period_start + 'T00:00:00Z');
                const periodEnd = new Date(periodStart);

                const periodType = document.getElementById('period').value;
                if (periodType === 'day') {
                    // End of the same day
                    periodEnd.setUTCHours(23, 59, 59, 999);
                } else { // week
                    // 6 days after the start day, at the end of the day
                    periodEnd.setUTCDate(periodEnd.getUTCDate() + 6);
                    periodEnd.setUTCHours(23, 59, 59, 999);
                }

                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;

                const drilldownContainer = document.getElementById('job-drilldown-container');
                const drilldownTitle = document.getElementById('job-drilldown-title');
                drilldownTitle.textContent = `Job Performance for period starting ${periodData.period_start}`;
                drilldownContainer.style.display = 'block';
                
                // Clear previous chart/message and show loading state
                document.getElementById('job-drilldown-message').textContent = 'Loading...';
                if (jobDrilldownChart) {
                    jobDrilldownChart.destroy();
                }
                document.getElementById('job-drilldown-chart').style.display = 'none';

                await loadJobDrilldownData(owner, repo, workflowId, periodStart.toISOString(), periodEnd.toISOString());
            }

            async function loadJobDrilldownData(owner, repo, workflowId, startDate, endDate) {
                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate
                });
                
                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }
                
                const apiUrl = `/api/jobs?${params.toString()}`;
                console.log(`Fetching job drilldown from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Job drilldown data:", responseData);
                    const data = responseData.data || responseData;
                    renderJobDrilldownChart(data);
                } catch (error) {
                    console.error("Failed to load job drilldown data:", error);
                    document.getElementById('job-drilldown-message').textContent = `Error: ${error.message}`;
                }
            }

            function renderJobDrilldownChart(data) {
                const messageEl = document.getElementById('job-drilldown-message');
                const chartCanvas = document.getElementById('job-drilldown-chart');
                const ctx = chartCanvas.getContext('2d');

                if (jobDrilldownChart) {
                    jobDrilldownChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No job data available for this period.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.job_name);
                const p95durationsMs = data.map(d => d.p95_duration_ms || null);
                
                // Determine the best unit
                const maxDuration = p95durationsMs.filter(d => d !== null).reduce((max, d) => Math.max(max, d), 0);
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                const p95durations = p95durationsMs.map(d => d ? (d / divisor) : null);

                jobDrilldownChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `P95 Duration (${unit}) - Successful Runs`,
                            data: p95durations,
                            backgroundColor: 'rgba(153, 102, 255, 0.6)'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.x !== null) { 
                                            const ms = context.parsed.x * divisor;
                                            label += formatDuration(ms);
                                        }
                                        return label;
                                    },
                                    afterLabel: function(context) {
                                        const jobData = data[context.dataIndex];
                                        return [`Total Runs: ${jobData.total_runs}`, `Success Rate: ${jobData.success_rate}%`];
                                    }
                                }
                            }
                        },
                        scales: { x: { beginAtZero: true, title: { display: true, text: `P95 Duration (${unit})` } } }
                    }
                });
            }

            async function loadSlowestJobs() {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId || !startDate || !endDate) {
                    return;
                }

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    limit: 10
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/jobs/slowest?${params.toString()}`;
                console.log(`Fetching slowest jobs from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Slowest jobs data:", responseData);
                    const data = responseData.data || responseData;
                    renderSlowestJobsChart(data);
                } catch (error) {
                    console.error("Failed to load slowest jobs:", error);
                    document.getElementById('slowest-jobs-message').textContent = `Error: ${error.message}`;
                }
            }

            function renderSlowestJobsChart(data) {
                const messageEl = document.getElementById('slowest-jobs-message');
                const chartCanvas = document.getElementById('slowest-jobs-chart');
                const ctx = chartCanvas.getContext('2d');

                if (slowestJobsChart) {
                    slowestJobsChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No job data available for the selected period.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.job_name.length > 40 ? d.job_name.substring(0, 37) + '...' : d.job_name);
                const p95durationsMs = data.map(d => d.p95_duration_ms || null);
                
                const maxDuration = p95durationsMs.filter(d => d !== null).reduce((max, d) => Math.max(max, d), 0);
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                const p95durations = p95durationsMs.map(d => d ? (d / divisor) : null);

                slowestJobsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `P95 Duration (${unit})`,
                            data: p95durations,
                            backgroundColor: 'rgba(255, 99, 132, 0.6)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        onClick: async (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const jobData = data[index];
                                currentJobSelection = jobData.job_name;
                                await loadStepsForJob(jobData.job_name);
                                await loadJobTrends(jobData.job_name);
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.x !== null) { 
                                            const ms = context.parsed.x * divisor;
                                            label += formatDuration(ms);
                                        }
                                        return label;
                                    },
                                    afterLabel: function(context) {
                                        const jobData = data[context.dataIndex];
                                        return [`Total Runs: ${jobData.total_runs}`, `Success Rate: ${jobData.success_rate}%`];
                                    }
                                }
                            }
                        },
                        scales: { 
                            x: { 
                                beginAtZero: true, 
                                title: { display: true, text: `P95 Duration (${unit})` } 
                            } 
                        }
                    }
                });
            }

            async function loadStepsForJob(jobName) {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                const stepContainer = document.getElementById('step-drilldown-container');
                const stepTitle = document.getElementById('step-drilldown-title');
                const messageEl = document.getElementById('step-drilldown-message');
                
                stepTitle.textContent = `Step Performance for: ${jobName}`;
                stepContainer.style.display = 'block';
                messageEl.textContent = 'Loading...';

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    job_name: jobName,
                    limit: 20
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/steps?${params.toString()}`;
                console.log(`Fetching steps for job from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Steps data:", responseData);
                    const data = responseData.data || responseData;
                    renderStepDrilldownChart(data);
                } catch (error) {
                    console.error("Failed to load steps:", error);
                    messageEl.textContent = `Error: ${error.message}`;
                }
            }

            function renderStepDrilldownChart(data) {
                const messageEl = document.getElementById('step-drilldown-message');
                const chartCanvas = document.getElementById('step-drilldown-chart');
                const ctx = chartCanvas.getContext('2d');

                if (stepDrilldownChart) {
                    stepDrilldownChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No step data available for this job.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.step_name.length > 50 ? d.step_name.substring(0, 47) + '...' : d.step_name);
                const avgDurationsMs = data.map(d => d.avg_success_duration_ms || d.avg_duration_ms || null);
                
                const maxDuration = avgDurationsMs.filter(d => d !== null).reduce((max, d) => Math.max(max, d), 0);
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                const avgDurations = avgDurationsMs.map(d => d ? (d / divisor) : null);

                stepDrilldownChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Avg Duration (${unit})`,
                            data: avgDurations,
                            backgroundColor: 'rgba(75, 192, 192, 0.6)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.x !== null) { 
                                            const ms = context.parsed.x * divisor;
                                            label += formatDuration(ms);
                                        }
                                        return label;
                                    },
                                    afterLabel: function(context) {
                                        const stepData = data[context.dataIndex];
                                        return [`Total Runs: ${stepData.total_runs}`, `Success Rate: ${stepData.success_rate}%`];
                                    }
                                }
                            }
                        },
                        scales: { 
                            x: { 
                                beginAtZero: true, 
                                title: { display: true, text: `Avg Duration (${unit})` } 
                            } 
                        }
                    }
                });
            }

            async function loadJobTrends(jobName) {
                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const period = document.getElementById('period').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                const trendContainer = document.getElementById('job-trend-container');
                const trendTitle = document.getElementById('job-trend-title');
                const messageEl = document.getElementById('job-trend-message');
                
                trendTitle.textContent = `Performance Trend for: ${jobName}`;
                trendContainer.style.display = 'block';
                messageEl.textContent = 'Loading...';

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    start_date: startDate,
                    end_date: endDate,
                    period: period
                });

                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const apiUrl = `/api/jobs/${encodeURIComponent(jobName)}/trends?${params.toString()}`;
                console.log(`Fetching job trends from: ${apiUrl}`);

                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`API Error (${response.status}): ${errorData.error || response.statusText}`);
                    }
                    const responseData = await response.json();
                    console.log("Job trends data:", responseData);
                    const data = responseData.data || responseData;
                    renderJobTrendChart(data);
                } catch (error) {
                    console.error("Failed to load job trends:", error);
                    messageEl.textContent = `Error: ${error.message}`;
                }
            }

            function renderJobTrendChart(data) {
                const messageEl = document.getElementById('job-trend-message');
                const chartCanvas = document.getElementById('job-trend-chart');
                const ctx = chartCanvas.getContext('2d');

                if (jobTrendChart) {
                    jobTrendChart.destroy();
                }

                if (!data || data.length === 0) {
                    messageEl.textContent = 'No trend data available for this job.';
                    chartCanvas.style.display = 'none';
                    return;
                }
                messageEl.textContent = '';
                chartCanvas.style.display = 'block';

                const labels = data.map(d => d.period_start);
                const allDurations = data.flatMap(d => [d.avg_duration_ms, d.p50_duration_ms, d.p95_duration_ms].filter(v => v !== null));
                const maxDuration = allDurations.length > 0 ? Math.max(...allDurations) : 0;
                const unit = getDurationUnit(maxDuration);
                const divisor = unit === 'hours' ? 3600000 : unit === 'minutes' ? 60000 : 1000;
                
                const avgDurationData = data.map(d => d.avg_duration_ms ? (d.avg_duration_ms / divisor) : null);
                const p95DurationData = data.map(d => d.p95_duration_ms ? (d.p95_duration_ms / divisor) : null);

                jobTrendChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `Average Duration (${unit})`,
                            data: avgDurationData,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            tension: 0.1,
                            fill: true
                        }, {
                            label: `P95 Duration (${unit})`,
                            data: p95DurationData,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            tension: 0.1,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (context.parsed.y !== null) {
                                            const ms = context.parsed.y * divisor;
                                            label += ': ' + formatDuration(ms);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `Duration (${unit})`
                                }
                            }
                        }
                    }
                });
            }

            async function loadData() {
                console.log("Loading data with current filters...");
                document.getElementById('job-drilldown-container').style.display = 'none';
                document.getElementById('step-drilldown-container').style.display = 'none';
                document.getElementById('job-trend-container').style.display = 'none';

                const owner = document.getElementById('repo-owner').value;
                const repo = document.getElementById('repo-name').value;
                const workflowId = document.getElementById('workflow-id').value;
                const period = document.getElementById('period').value;
                const startDateValue = document.getElementById('start-date').value;
                const endDateValue = document.getElementById('end-date').value;

                // Convert YYYY-MM-DD to a full ISO string at the start/end of the day in UTC.
                const startDate = startDateValue ? new Date(startDateValue + 'T00:00:00Z').toISOString() : '';
                const endDate = endDateValue ? new Date(endDateValue + 'T23:59:59.999Z').toISOString() : '';

                if (!owner || !repo || !workflowId) {
                    console.log("Skipping API call: Owner, Repo, and Workflow ID are required.");
                    return;
                }

                const params = new URLSearchParams({
                    owner,
                    repo,
                    workflow_id: workflowId,
                    period,
                });

                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);
                
                const selectedConclusions = getSelectedConclusions();
                if (selectedConclusions.length > 0) {
                    params.append('conclusions', selectedConclusions.join(','));
                }

                const trendsUrl = `/api/trends?${params.toString()}`;
                const overallMetricsUrl = `/api/overall-metrics?${params.toString()}`;
                console.log(`Fetching trends from: ${trendsUrl}`);
                console.log(`Fetching overall metrics from: ${overallMetricsUrl}`);

                try {
                    // Fetch both trends and overall metrics in parallel
                    const [trendsResponse, overallMetricsResponse] = await Promise.all([
                        fetch(trendsUrl),
                        fetch(overallMetricsUrl)
                    ]);
                    
                    if (!trendsResponse.ok) {
                        const errorData = await trendsResponse.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`Trends API Error (${trendsResponse.status}): ${errorData.error || trendsResponse.statusText}`);
                    }
                    
                    if (!overallMetricsResponse.ok) {
                        const errorData = await overallMetricsResponse.json().catch(() => ({ error: 'Failed to parse error JSON' }));
                        throw new Error(`Overall Metrics API Error (${overallMetricsResponse.status}): ${errorData.error || overallMetricsResponse.statusText}`);
                    }
                    
                    const trendsData = await trendsResponse.json();
                    const overallMetrics = await overallMetricsResponse.json();

                    console.log("Trends API Response Data:", trendsData);
                    console.log("Overall Metrics API Response Data:", overallMetrics);
                    
                    // Extract the data array from the response (API returns {data: [...], metadata: {...}})
                    const data = trendsData.data || trendsData;
                    currentTrendsData = data;
                    
                    renderSummaryMetrics(data, overallMetrics);
                    renderTrendsChart(data);
                    renderOutcomesChart(data);
                    renderRunsPerPeriodChart(data);
                    
                    // Load slowest jobs
                    await loadSlowestJobs();
                } catch (error) {
                    console.error("Failed to load data:", error);
                }
            }
        </script>
    </div>
</body>
</html>
